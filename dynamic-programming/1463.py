'''
1로 만들기
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
0.15 초 (하단 참고)	128 MB	260842	87384	55797	32.597%
문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

입력
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

예제 입력 1 
2
예제 출력 1 
1
예제 입력 2 
10
예제 출력 2 
3
'''

'''
dp[N]은 N을 2로 나눈(나누어떨어졌을경우만 포함)
OR 3으로나눈(나누어 떨어졌으르 경우만)
OR 1을 뺀 dp값들중 최솟값에 +1한 값이다.
ex>
dp[8]=min(dp[7], dp[4])+1
8=4*2로 나타낼수있고
4=2*2로 나타낼수있다.
이런식으로 8이라는 하나의 문제를 더 작은 하위 문제들로 분할할 수 있다.
'''
N=int(input())
dp=[0]*(N+1)
dp[1]=0
if(N>=2):
    dp[2]=1
    if(N>=3):    
        dp[3]=1

for i in range(4, N+1):
    if i%2==0 and i%3==0:
        dp[i]=min(dp[i//2], dp[i//3], dp[i-1])+1
    elif i%2==0:
        dp[i]=min(dp[i//2], dp[i-1])+1
    elif i%3==0:
        dp[i]=min(dp[i//3],dp[i-1])+1
    else:
        dp[i]=dp[i-1]+1
    
print(dp[N])
'''
**Bottom-Up 방식**
이름에서 보이듯이, **아래에서 부터 계산을 수행 하고 누적시켜서
전체 큰 문제를 해결하는 방식**이다.
메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, 
**dp[n]을 목표 상태라고 하자. Bottom-up은 dp[1]부터 시작하여 
반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이**시켜 재활용하는 방식이다.
'''